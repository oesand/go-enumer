package internal

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"unicode"
)

const fileHeaderText = "// Code generated by go-enumer[" + ProjectLink + "]. DO NOT EDIT! \n\n"

var (
	supportedTypes = map[string]string{
		"string": "string",
		"int":    "int",
		"int32":  "int",
		"int64":  "int",
	}
)

func GenerateEnumFile(fileName, packageName string, enums []*FutureEnum) error {
	if len(enums) == 0 {
		return nil
	}
	absolutePath, err := filepath.Abs(fileName)
	if err != nil {
		return fmt.Errorf("fail to get absolute path fot output file: %s", err)
	}

	var buf bytes.Buffer
	buf.WriteString(fileHeaderText)
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	for _, enumInfo := range enums {
		// Generate const values
		buf.WriteString(fmt.Sprintf("// %s enum declarations\nconst (\n", enumInfo.EnumName))
		switch enumInfo.TypeName { // Generate enum values long name const
		case "int":
			buf.WriteString(fmt.Sprintf("\t_%sName = \"", enumInfo.EnumName))
			for _, value := range enumInfo.ValueNames {
				buf.WriteString(value)
			}
			buf.WriteString("\"\n")
		}

		for i, value := range enumInfo.ValueNames { // Generate enum values
			fieldName := genEnumName(value, enumInfo.EnumName, enumInfo.reversedName)
			if !unicode.IsLetter(rune(value[0])) {
				return fmt.Errorf("generated invalid nama for enum value(%s) with 'reversed' tag", fieldName)
			}
			switch enumInfo.TypeName {
			case "int":
				if i == 0 {
					buf.WriteString(fmt.Sprintf("\t%s %s = iota\n", fieldName, enumInfo.EnumName))
				} else {
					buf.WriteString(fmt.Sprintf("\t%s\n", fieldName))
				}
			case "string":
				buf.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", fieldName, enumInfo.EnumName, value))
			}
		}
		buf.WriteString(")\n\n")

		// Generate name list
		switch enumInfo.TypeName {
		case "int":
			buf.WriteString(fmt.Sprintf("var _%sNames = []string{\n", enumInfo.EnumName))
			prevIndex := 0
			for _, value := range enumInfo.ValueNames {
				newIndex := prevIndex + len(value)
				buf.WriteString(fmt.Sprintf("\t_%sName[%d:%d],\n", enumInfo.EnumName, prevIndex, newIndex))
				prevIndex = newIndex
			}
			buf.WriteString("}\n\n")

			buf.WriteString(fmt.Sprintf("var _%sMap = map[string]%s{\n", enumInfo.EnumName, enumInfo.EnumName))
			prevIndex = 0
			for _, value := range enumInfo.ValueNames {
				fieldName := genEnumName(value, enumInfo.EnumName, enumInfo.reversedName)
				newIndex := prevIndex + len(value)
				buf.WriteString(fmt.Sprintf("\t_%sName[%d:%d]: %s,\n", enumInfo.EnumName, prevIndex, newIndex, fieldName))
				prevIndex = newIndex
			}
			buf.WriteString("}\n\n")

			buf.WriteString(fmt.Sprintf("func %sNames() []string {\n\treturn _%sNames\n}\n\n",
				enumInfo.EnumName, enumInfo.EnumName))

			buf.WriteString(fmt.Sprintf("func %sFromString(value string) (%s, bool) {"+
				"\n\tenum, has := _%sMap[value]\n\treturn enum, has\n}\n\n",
				enumInfo.EnumName, enumInfo.EnumName, enumInfo.EnumName))

			buf.WriteString(fmt.Sprintf("func (en %s) IsValid() bool {\n\treturn 0 < en && en <= %d\n}\n\n",
				enumInfo.EnumName, len(enumInfo.ValueNames)))

		case "string":
			buf.WriteString(fmt.Sprintf("func (en %s) IsValid() bool {\n\treturn ", enumInfo.EnumName))

			for i, value := range enumInfo.ValueNames {
				fieldName := genEnumName(value, enumInfo.EnumName, enumInfo.reversedName)
				if i == 0 {
					buf.WriteString(fmt.Sprintf("en == %s", fieldName))
				} else {
					buf.WriteString(fmt.Sprintf(" ||\n\t\ten == %s", fieldName))
				}
			}

			buf.WriteString("\n}\n\n")
		}

		buf.WriteString(fmt.Sprintf("func %sValues() []%s {\n\treturn []%s{\n",
			enumInfo.EnumName, enumInfo.EnumName, enumInfo.EnumName))

		for _, value := range enumInfo.ValueNames {
			fieldName := genEnumName(value, enumInfo.EnumName, enumInfo.reversedName)
			buf.WriteString(fmt.Sprintf("\t\t%s,\n", fieldName))
		}

		buf.WriteString("\t}\n}\n\n")

		buf.WriteString(fmt.Sprintf("func (en %s) String() string { \n", enumInfo.EnumName))
		switch enumInfo.TypeName {
		case "int":
			buf.WriteString(fmt.Sprintf("\treturn _%sNames[en]\n}\n\n", enumInfo.EnumName))
		case "string":
			buf.WriteString("\treturn string(en)\n}\n\n")
		}
	}

	return os.WriteFile(absolutePath, buf.Bytes(), 0644)
}

func genEnumName(name, enumName string, reversed bool) string {
	if reversed {
		return toPascalCase(name) + enumName
	}
	return enumName + toPascalCase(name)
}
